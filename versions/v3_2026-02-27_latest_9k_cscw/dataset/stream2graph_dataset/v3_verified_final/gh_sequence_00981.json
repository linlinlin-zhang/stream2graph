{
  "id": "gh_sequence_00981",
  "source": "github",
  "source_url": "https://github.com/AdasRakieta/Site_proj/blob/94c158d0e04d4807cd0a144d3e2468f2a17c7473/Inzynierka/In%C5%BCynierka_01/12_ZALACZNIKI/diagramy/sekwencje_automation.mmd",
  "github_repo": "AdasRakieta/Site_proj",
  "github_file_path": "Inzynierka/Inżynierka_01/12_ZALACZNIKI/diagramy/sekwencje_automation.mmd",
  "diagram_type": "sequence",
  "code": "﻿---\nconfig:\n  theme: dark\n---\nsequenceDiagram\n    actor User\n    participant UI as Browser UI\n    participant Flask as Flask App\n    participant Socket as Socket.IO Server\n    participant Routes as RoutesManager\n    participant Executor as AutomationExecutor\n    participant MultiDB as MultiHomeDBManager\n    participant PG as PostgreSQL\n    participant Redis as Redis Cache\n    \n    Note over User,Redis: Użytkownik zmienia stan urządzenia (wyzwalacz automatyzacji)\n    \n    User->>UI: Click device toggle/button\n    UI->>Socket: emit('toggle_button', device_data)\n    Socket->>Routes: handle_toggle_button()\n    Routes->>MultiDB: update_device(device_id, state)\n    MultiDB->>PG: UPDATE devices SET state=...\n    PG-->>MultiDB: rows affected\n    MultiDB-->>Routes: success\n    \n    Note over Routes,Redis: Invalidacja cache dla zmienionego urządzenia\n    Routes->>Redis: delete cache_key(home_id, devices)\n    \n    Note over Routes,Executor: Sprawdzenie automatyzacji dla tego urządzenia\n    Routes->>Executor: process_device_trigger(device_id, room, name, state, home_id, user_id)\n    \n    Executor->>MultiDB: get_home_automations(home_id, user_id)\n    MultiDB->>PG: SELECT * FROM home_automations WHERE home_id=... AND enabled=true\n    PG-->>MultiDB: automations list\n    MultiDB-->>Executor: automations[]\n    \n    Note over Executor: Filtrowanie automatyzacji według triggera\n    loop Each automation\n        Executor->>Executor: Check if trigger.type=='device'\n        Executor->>Executor: Check if trigger.device matches device_key\n        Executor->>Executor: Check if trigger.state matches new_state\n    end\n    \n    alt Automation matched\n        Note over Executor: Wykonanie automatyzacji\n        Executor->>Executor: _execute_automation(automation, home_id, user_id, trigger_data)\n        \n        loop Each action in actions_config\n            alt action.type == 'device'\n                Executor->>MultiDB: get_home_devices(home_id, user_id, 'button')\n                MultiDB->>PG: SELECT devices WHERE device_type='button'\n                PG-->>MultiDB: devices[]\n                MultiDB-->>Executor: target_device\n                \n                Executor->>Executor: Calculate new_state (on/off/toggle)\n                Executor->>MultiDB: update_device(target_device_id, user_id, state=new_state)\n                MultiDB->>PG: UPDATE devices SET state=...\n                PG-->>MultiDB: rows affected\n                \n                Executor->>Socket: emit('update_button', {room, name, state, device_id})\n                Socket-->>UI: Update button UI\n                Executor->>Socket: emit('sync_button_states', state_map)\n                Socket-->>UI: Sync all buttons\n                \n            else action.type == 'thermostat_control'\n                Executor->>MultiDB: get_home_devices(home_id, user_id, 'temperature_control')\n                MultiDB->>PG: SELECT devices WHERE device_type='temperature_control'\n                PG-->>MultiDB: devices[]\n                MultiDB-->>Executor: thermostat_device\n                \n                Executor->>MultiDB: update_device(thermostat_id, user_id, state=new_state)\n                MultiDB->>PG: UPDATE devices SET state=...\n                Executor->>Socket: emit('update_temperature', {room, name, state, temp})\n                Socket-->>UI: Update thermostat UI\n                \n            else action.type == 'set_temperature'\n                Executor->>MultiDB: get_home_devices(home_id, user_id, 'temperature_control')\n                Executor->>MultiDB: update_device(thermostat_id, user_id, temperature=target_temp)\n                MultiDB->>PG: UPDATE devices SET temperature=...\n                Executor->>Socket: emit('update_temperature', data)\n                Socket-->>UI: Update temperature display\n                \n            else action.type == 'notification'\n                Note over Executor: Email notification (future)\n                Executor->>Executor: _execute_notification_action()\n            end\n        end\n        \n        Note over Executor: Logowanie wykonania automatyzacji\n        Executor->>Executor: Calculate execution_time_ms\n        Executor->>Executor: _log_execution(automation_id, status, trigger_data, actions_executed)\n        Executor->>MultiDB: log_automation_execution(...)\n        MultiDB->>PG: INSERT INTO automation_executions (...)\n        PG-->>MultiDB: execution_id\n        \n        Executor->>MultiDB: update_automation_stats(automation_id, execution_count++)\n        MultiDB->>PG: UPDATE home_automations SET execution_count=execution_count+1, last_executed=NOW()\n        \n        Executor-->>Routes: execution_result{status, actions_executed, errors, execution_time_ms}\n    end\n    \n    Note over Routes,Socket: Broadcast zaktualizowanego stanu do wszystkich klientów\n    Routes->>Socket: emit('update_button', device_state)\n    Socket-->>UI: Real-time update for all connected clients\n    Routes->>Socket: emit('sync_button_states', all_states)\n    Socket-->>UI: Synchronize all device states\n    \n    Routes-->>Socket: success response\n    Socket-->>UI: Confirm toggle\n    UI-->>User: Visual feedback (updated state)\n    \n    Note over User,Redis: Automatyzacja zakończona - urządzenia zaktualizowane w czasie rzeczywistym\n",
  "content_size": 5265,
  "collected_at": "2026-02-06T01:51:29.067240",
  "compilation_status": "failed",
  "compilation_error": "[WinError 2] 系统找不到指定的文件。",
  "license": "mit",
  "license_name": "MIT License",
  "license_url": "https://api.github.com/licenses/mit",
  "repo_stars": 1,
  "repo_forks": 0
}