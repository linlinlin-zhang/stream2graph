{
  "id": "gh_mindmap_02000",
  "source": "github",
  "source_url": "https://github.com/Rethishkumar/DDIA/blob/30c65cae1d4613fef3916d49d399425fe74c3dfe/mindmap/replication_leaderbased.mmd",
  "github_repo": "Rethishkumar/DDIA",
  "github_file_path": "mindmap/replication_leaderbased.mmd",
  "diagram_type": "mindmap",
  "code": "mindmap\n  root((Replication))\n    id1[\"`**Single Leader / Leader Based**. Clients send writes to leader. Leader writes to local storage and sends change to followers.`\"]\n        Sync/Async Replication\n            id1[\"`**Sync** All followers written in sync. Not usualy used as can't make all followers sync`\"]\n            id1[\"`**Semi-Sync** Some followers written in sync and others async.`\"]\n            id1[\"`**Async** All followers written in Async. Leader can still continue processing writes. Used more widely used than others`\"]\n        Handling Node Outages\n            id1[\"`**Follower failure - Catchup Recovery** Each follower keeps log of data chnages recvd from leader. When joining back requestes changes since last disconected.`\"]\n            id1[\"`**Leader failure - Failover** On leader outage. Clients need to be reconfigured to send to new leader.`\"]\n                id1[\"`**Failover process**\n                *Determine leader has failed*: Via say heartbeats \n                *Chosing New Leader*: Via election process or via a controlling node. Usually leader is node that las latest update. \n                *Reconfiguring system for new leader*: Clients need to send to new leader. New leader when coming back should join as follwer and not leader`\"]\n                id1[\"`**Failover Gotchas** \n                *Conflicts*: if leader was written to during outage there could be conflicting writes\n                *Keys*: If conflicting data is discarded. sequential keys generated in new leader and old leader may get overwritten causing user to see others data etc\n                *Split Brain:* Safety mechanisms required for ensuring only one leader exists\n                *Leader Timeout:* Long timeout causes longer recocovery. Shorter Timeouts cause oscillating and unnecessary failures.`\"]\n        How does Leader based replication work?\n            id1[\"`**Statement based relication** \n            Each write request statement is sent to followers.\n            *Cons:* some statement may have calaucted values or auto incrementing sequences or side effects such as triggers.\n            Not generally preferred`\"]\n            id1[\"`**Write Ahead Logs (WAL) shipping** \n            The LSM tree log statement (physical data representation) is sent to followers. Follower processes the log and build a replica.\n            *Cons:* The logs are in machine native format. So version upgrades etc are difficult. Leaders and followers should be on same version.`\"]\n            id1[\"`**Logical (row-based) replication** \n            Log statement is logical info eg; For an insert all values of columns, For deletion the primary key etc.\n            Easier for external tools to parse and use ; Used in Change Data Capture.`\"]\n            id1[\"`**Trigger based replication** \n            Triggeres done to application code and application code responsible for replicaticating data chnage. Uses Triggeres/Stored Procedures.`\"]\n        Problems with replication\n            id1[\"`**Read own Writes** \n                Application writes to leader and reads from a follower which doesn't have the update. \n                *Solution:* Read own updates from leader itself. eg. user profile update should always be from leader. other profiles may be from followers.\n                OR on an update read from leader for some duration and after that read from followers.\n                OR add a counter for each update and if read from follower has a lower counter read from somewhere else.\n                *Cons*: Cross device reads can't track upates so would get stale information`\"]\n            id1[\"`**Monotonic Reads**\n                App reads from replica which has Update U2 but next read on another replica with previous update. So app may see updates going backward\n                Monotonic reads is a gurantee < Strong consistency but > eventual.\n                *Solution:* App always reads from same replica or set of replica. The replica(set) is determined via User Id hash.`\"]\n            id1[\"`**Consistent Prefix Reads**\n                Sequence of writes happen in an order and reads for them also happen in order.\n                Else, Updates to related information can go out of sync.`\"]\n        Solution for replication lag: Transactions\n        \n\n\n",
  "content_size": 4291,
  "collected_at": "2026-02-06T02:06:15.758445",
  "compilation_status": "success",
  "license": "mit",
  "license_name": "MIT License",
  "license_url": "https://api.github.com/licenses/mit",
  "repo_stars": 0,
  "repo_forks": 0,
  "repo_owner": "Rethishkumar",
  "repo_name": "DDIA",
  "repo_description": "Learning from Designing Data Intensive Applications",
  "repo_language": "Mermaid",
  "repo_topics": [],
  "repo_created_at": "2024-08-11T14:31:52Z",
  "repo_updated_at": "2025-07-21T03:04:08Z",
  "cscw_dialogue": [
    {
      "turn_id": 1,
      "role": "Domain_Expert",
      "action_type": "propose",
      "utterance": "用户在这里会遇到 (Replication 和 \"`**Single Leader / Leader Based**. Clients send writes to leader. Leader writes to local storage and sends change to followers.`\" 的分支。",
      "elements_involved": [],
      "is_repair": false
    },
    {
      "turn_id": 2,
      "role": "Domain_Expert",
      "action_type": "repair",
      "utterance": "等等，我重新想了一下，应该是 (Replication处理 才对。",
      "elements_involved": [],
      "is_repair": true
    },
    {
      "turn_id": 3,
      "role": "Diagram_Editor",
      "action_type": "clarify",
      "utterance": "收到。这是不是一个判断条件？我暂时写成 '(Replication处理'。",
      "elements_involved": [],
      "is_repair": false
    },
    {
      "turn_id": 4,
      "role": "Domain_Expert",
      "action_type": "confirm",
      "utterance": "没问题。",
      "elements_involved": [],
      "is_repair": false
    },
    {
      "turn_id": 5,
      "role": "Diagram_Editor",
      "action_type": "execute",
      "utterance": "[系统日志: Editor 更新了图表代码以反映上述结构]",
      "elements_involved": [
        "root",
        "id1"
      ],
      "is_repair": false
    },
    {
      "turn_id": 6,
      "role": "Domain_Expert",
      "action_type": "propose",
      "utterance": "这里必须包含 \"`**Sync** All followers written in sync. Not usualy used as can't make all followers sync`\" 和 \"`**Semi-Sync** Some followers written in sync and others async.`\" 这一块。",
      "elements_involved": [],
      "is_repair": false
    },
    {
      "turn_id": 7,
      "role": "Diagram_Editor",
      "action_type": "clarify",
      "utterance": "好的，我把它画成一个矩形框，名字叫 '\"`**Sync** All followers written in sync. Not usualy used as can't make all followers sync`\" 和 \"`**Semi-Sync** Some followers written in sync and others async.`\"'，对吧？",
      "elements_involved": [],
      "is_repair": false
    },
    {
      "turn_id": 8,
      "role": "Domain_Expert",
      "action_type": "confirm",
      "utterance": "可以，继续吧。",
      "elements_involved": [],
      "is_repair": false
    },
    {
      "turn_id": 9,
      "role": "Diagram_Editor",
      "action_type": "execute",
      "utterance": "[系统日志: Editor 更新了图表代码以反映上述结构]",
      "elements_involved": [
        "id1",
        "id1"
      ],
      "is_repair": false
    },
    {
      "turn_id": 10,
      "role": "Domain_Expert",
      "action_type": "propose",
      "utterance": "这里必须包含 \"`**Async** All followers written in Async. Leader can still continue processing writes. Used more widely used than others`\" 和 \"`**Follower failure - Catchup Recovery** Each follower keeps log of data chnages recvd from leader. When joining back requestes changes since last disconected.`\" 这一块。",
      "elements_involved": [],
      "is_repair": false
    },
    {
      "turn_id": 11,
      "role": "Diagram_Editor",
      "action_type": "clarify",
      "utterance": "好的，我把它画成一个矩形框，名字叫 '\"`**Async** All followers written in Async. Leader can still continue processing writes. Used more widely used than others`\" 和 \"`**Follower failure - Catchup Recovery** Each follower keeps log of data chnages recvd from leader. When joining back requestes changes since last disconected.`\"'，对吧？",
      "elements_involved": [],
      "is_repair": false
    },
    {
      "turn_id": 12,
      "role": "Domain_Expert",
      "action_type": "confirm",
      "utterance": "对的，就这样。",
      "elements_involved": [],
      "is_repair": false
    },
    {
      "turn_id": 13,
      "role": "Diagram_Editor",
      "action_type": "execute",
      "utterance": "[系统日志: Editor 更新了图表代码以反映上述结构]",
      "elements_involved": [
        "id1",
        "id1"
      ],
      "is_repair": false
    },
    {
      "turn_id": 14,
      "role": "Domain_Expert",
      "action_type": "propose",
      "utterance": "我们需要加一个处理 \"`**Leader failure - Failover** On leader outage. Clients need to be reconfigured to send to new leader.`\" 和 \"`**Failover process**\n                *Determine leader has failed*: Via say heartbeats \n                *Chosing New Leader*: Via election process or via a controlling node. Usually leader is node that las latest update. \n                *Reconfiguring system for new leader*: Clients need to send to new leader. New leader when coming back should join as follwer and not leader`\" 的环节。",
      "elements_involved": [],
      "is_repair": false
    },
    {
      "turn_id": 15,
      "role": "Diagram_Editor",
      "action_type": "clarify",
      "utterance": "收到。这是不是一个判断条件？我暂时写成 '\"`**Leader failure - Failover** On leader outage. Clients need to be reconfigured to send to new leader.`\" 和 \"`**Failover process**\n                *Determine leader has failed*: Via say heartbeats \n                *Chosing New Leader*: Via election process or via a controlling node. Usually leader is node that las latest update. \n                *Reconfiguring system for new leader*: Clients need to send to new leader. New leader when coming back should join as follwer and not leader`\"'。",
      "elements_involved": [],
      "is_repair": false
    },
    {
      "turn_id": 16,
      "role": "Domain_Expert",
      "action_type": "confirm",
      "utterance": "没问题。",
      "elements_involved": [],
      "is_repair": false
    },
    {
      "turn_id": 17,
      "role": "Diagram_Editor",
      "action_type": "execute",
      "utterance": "[系统日志: Editor 更新了图表代码以反映上述结构]",
      "elements_involved": [
        "id1",
        "id1"
      ],
      "is_repair": false
    },
    {
      "turn_id": 18,
      "role": "Domain_Expert",
      "action_type": "propose",
      "utterance": "接下来是关于 \"`**Failover Gotchas** \n                *Conflicts*: if leader was written to during outage there could be conflicting writes\n                *Keys*: If conflicting data is discarded. sequential keys generated in new leader and old leader may get overwritten causing user to see others data etc\n                *Split Brain:* Safety mechanisms required for ensuring only one leader exists\n                *Leader Timeout:* Long timeout causes longer recocovery. Shorter Timeouts cause oscillating and unnecessary failures.`\" 和 \"`**Statement based relication** \n            Each write request statement is sent to followers.\n            *Cons:* some statement may have calaucted values or auto incrementing sequences or side effects such as triggers.\n            Not generally preferred`\" 的逻辑。",
      "elements_involved": [],
      "is_repair": false
    },
    {
      "turn_id": 19,
      "role": "Diagram_Editor",
      "action_type": "clarify",
      "utterance": "好的，我把它画成一个矩形框，名字叫 '\"`**Failover Gotchas** \n                *Conflicts*: if leader was written to during outage there could be conflicting writes\n                *Keys*: If conflicting data is discarded. sequential keys generated in new leader and old leader may get overwritten causing user to see others data etc\n                *Split Brain:* Safety mechanisms required for ensuring only one leader exists\n                *Leader Timeout:* Long timeout causes longer recocovery. Shorter Timeouts cause oscillating and unnecessary failures.`\" 和 \"`**Statement based relication** \n            Each write request statement is sent to followers.\n            *Cons:* some statement may have calaucted values or auto incrementing sequences or side effects such as triggers.\n            Not generally preferred`\"'，对吧？",
      "elements_involved": [],
      "is_repair": false
    },
    {
      "turn_id": 20,
      "role": "Domain_Expert",
      "action_type": "confirm",
      "utterance": "嗯，这样看起来很清晰。",
      "elements_involved": [],
      "is_repair": false
    },
    {
      "turn_id": 21,
      "role": "Diagram_Editor",
      "action_type": "execute",
      "utterance": "[系统日志: Editor 更新了图表代码以反映上述结构]",
      "elements_involved": [
        "id1",
        "id1"
      ],
      "is_repair": false
    },
    {
      "turn_id": 22,
      "role": "Domain_Expert",
      "action_type": "propose",
      "utterance": "接下来是关于 \"`**Write Ahead Logs (WAL 和 physical data representation 的逻辑。",
      "elements_involved": [],
      "is_repair": false
    },
    {
      "turn_id": 23,
      "role": "Diagram_Editor",
      "action_type": "clarify",
      "utterance": "好的，我把它画成一个矩形框，名字叫 '\"`**Write Ahead Logs (WAL 和 physical data representation'，对吧？",
      "elements_involved": [],
      "is_repair": false
    },
    {
      "turn_id": 24,
      "role": "Domain_Expert",
      "action_type": "confirm",
      "utterance": "嗯，这样看起来很清晰。",
      "elements_involved": [],
      "is_repair": false
    },
    {
      "turn_id": 25,
      "role": "Diagram_Editor",
      "action_type": "execute",
      "utterance": "[系统日志: Editor 更新了图表代码以反映上述结构]",
      "elements_involved": [
        "id1",
        "statement"
      ],
      "is_repair": false
    },
    {
      "turn_id": 26,
      "role": "Domain_Expert",
      "action_type": "propose",
      "utterance": "然后，流程会走到 \"`**Logical (row-based 和 \"`**Trigger based replication** \n            Triggeres done to application code and application code responsible for replicaticating data chnage. Uses Triggeres/Stored Procedures.`\"。",
      "elements_involved": [],
      "is_repair": false
    },
    {
      "turn_id": 27,
      "role": "Diagram_Editor",
      "action_type": "clarify",
      "utterance": "收到。这是不是一个判断条件？我暂时写成 '\"`**Logical (row-based 和 \"`**Trigger based replication** \n            Triggeres done to application code and application code responsible for replicaticating data chnage. Uses Triggeres/Stored Procedures.`\"'。",
      "elements_involved": [],
      "is_repair": false
    },
    {
      "turn_id": 28,
      "role": "Domain_Expert",
      "action_type": "confirm",
      "utterance": "没问题。",
      "elements_involved": [],
      "is_repair": false
    },
    {
      "turn_id": 29,
      "role": "Diagram_Editor",
      "action_type": "execute",
      "utterance": "[系统日志: Editor 更新了图表代码以反映上述结构]",
      "elements_involved": [
        "id1",
        "id1"
      ],
      "is_repair": false
    },
    {
      "turn_id": 30,
      "role": "Domain_Expert",
      "action_type": "propose",
      "utterance": "然后，流程会走到 \"`**Read own Writes** \n                Application writes to leader and reads from a follower which doesn't have the update. \n                *Solution:* Read own updates from leader itself. eg. user profile update should always be from leader. other profiles may be from followers.\n                OR on an update read from leader for some duration and after that read from followers.\n                OR add a counter for each update and if read from follower has a lower counter read from somewhere else.\n                *Cons*: Cross device reads can't track upates so would get stale information`\" 和 \"`**Monotonic Reads**\n                App reads from replica which has Update U2 but next read on another replica with previous update. So app may see updates going backward\n                Monotonic reads is a gurantee < Strong consistency but > eventual.\n                *Solution:* App always reads from same replica or set of replica. The replica(set。",
      "elements_involved": [],
      "is_repair": false
    },
    {
      "turn_id": 31,
      "role": "Diagram_Editor",
      "action_type": "clarify",
      "utterance": "我把它加进去了，标签显示为 '\"`**Read own Writes** \n                Application writes to leader and reads from a follower which doesn't have the update. \n                *Solution:* Read own updates from leader itself. eg. user profile update should always be from leader. other profiles may be from followers.\n                OR on an update read from leader for some duration and after that read from followers.\n                OR add a counter for each update and if read from follower has a lower counter read from somewhere else.\n                *Cons*: Cross device reads can't track upates so would get stale information`\" 和 \"`**Monotonic Reads**\n                App reads from replica which has Update U2 but next read on another replica with previous update. So app may see updates going backward\n                Monotonic reads is a gurantee < Strong consistency but > eventual.\n                *Solution:* App always reads from same replica or set of replica. The replica(set'，你看看合适吗？",
      "elements_involved": [],
      "is_repair": false
    },
    {
      "turn_id": 32,
      "role": "Domain_Expert",
      "action_type": "confirm",
      "utterance": "对的，就这样。",
      "elements_involved": [],
      "is_repair": false
    },
    {
      "turn_id": 33,
      "role": "Diagram_Editor",
      "action_type": "execute",
      "utterance": "[系统日志: Editor 更新了图表代码以反映上述结构]",
      "elements_involved": [
        "id1",
        "id1"
      ],
      "is_repair": false
    },
    {
      "turn_id": 34,
      "role": "Domain_Expert",
      "action_type": "propose",
      "utterance": "用户在这里会遇到 \"`**Consistent Prefix Reads**\n                Sequence of writes happen in an order and reads for them also happen in order.\n                Else, Updates to related information can go out of sync.`\" 的分支。",
      "elements_involved": [],
      "is_repair": false
    },
    {
      "turn_id": 35,
      "role": "Domain_Expert",
      "action_type": "repair",
      "utterance": "抱歉，稍微改一下，把刚才那个改成 \"`**Consistent Prefix Reads**\n                Sequence of writes happen in an order and reads for them also happen in order.\n                Else, Updates to related information can go out of sync.`\"处理。",
      "elements_involved": [],
      "is_repair": true
    },
    {
      "turn_id": 36,
      "role": "Diagram_Editor",
      "action_type": "clarify",
      "utterance": "明白，所以它是承接上一步的，内容是 '\"`**Consistent Prefix Reads**\n                Sequence of writes happen in an order and reads for them also happen in order.\n                Else, Updates to related information can go out of sync.`\"处理'？",
      "elements_involved": [],
      "is_repair": false
    },
    {
      "turn_id": 37,
      "role": "Domain_Expert",
      "action_type": "confirm",
      "utterance": "没问题。",
      "elements_involved": [],
      "is_repair": false
    },
    {
      "turn_id": 38,
      "role": "Diagram_Editor",
      "action_type": "execute",
      "utterance": "[系统日志: Editor 更新了图表代码以反映上述结构]",
      "elements_involved": [
        "id1"
      ],
      "is_repair": false
    }
  ],
  "dialogue_metadata": {
    "total_turns": 38,
    "repair_count": 2,
    "grounding_acts_count": 18,
    "theoretical_framework": "Grounding in Communication (Clark & Brennan, 1991)"
  },
  "repaired_at": "2026-02-28T13:41:23Z"
}