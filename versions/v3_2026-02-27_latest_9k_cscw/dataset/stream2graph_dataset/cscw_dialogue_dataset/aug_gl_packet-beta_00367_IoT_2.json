{
  "id": "aug_gl_packet-beta_00367_IoT_2",
  "source": "augmented_real_structure",
  "source_url": "https://github.com/ArgOsciProyect/ARG_OSCI_APP/blob/5b219c846361cf23dbe85c073aba8d9146c704d5/diagrams/TRIGGER_ALG_DIAG.mmd",
  "source_note": "collected_from_github_additional",
  "github_repo": "ArgOsciProyect/ARG_OSCI_APP",
  "diagram_type": "packet-beta",
  "code": "sequenceDiagram\n    participant Queue as Raw Data Queue\n    participant Processor as ProcessingIsolate\n    participant TriggerAlgo as Trigger Detection Algorithm\n    participant Validator as Trigger Validator\n    participant Interpolator as Trigger Point Interpolator\n    participant DataService\n    \n    Queue->>Processor: Provide raw binary data packet\n    \n    %% Data extraction phase\n    Processor->>Processor: Extract data points from queue using _readDataFromQueue(IoT_Industrial_EdgeNode)\n    Processor->>Processor: Apply bit masks to separate data and channel\n    Processor->>Processor: Convert to voltage using scale factor\n    Processor->>Processor: Calculate max/min values of signal\n    \n    %% Prepare for trigger detection\n    Processor->>Processor: Calculate trigger sensitivity based on signal amplitude\n    Note over Processor: sensitivity = (IoT_Industrial_TelemetryStream) * 0.25\n    \n    %% Apply filter if needed\n    alt useLowPassFilter = true\n        Processor->>Processor: Apply low-pass filter to signal for trigger detection\n        Note over Processor: Creates filtered signal for stable triggering\n    else useLowPassFilter = false\n        Processor->>Processor: Use unfiltered signal values for trigger detection\n    end\n    \n    %% Main detection loop\n    loop For each adjacent point pair\n        Processor->>TriggerAlgo: Check for trigger condition\n        \n        %% First check for exact trigger level match\n        TriggerAlgo->>TriggerAlgo: Check if either point exactly matches trigger level\n        \n        alt No exact match\n            %% Check for level crossing\n            alt Trigger edge = Positive\n                TriggerAlgo->>TriggerAlgo: Check if prevY < triggerLevel && currentY >= triggerLevel\n                Note over TriggerAlgo: Rising edge detection\n            else Trigger edge = Negative\n                TriggerAlgo->>TriggerAlgo: Check if prevY > triggerLevel && currentY <= triggerLevel\n                Note over TriggerAlgo: Falling edge detection\n            end\n        end\n        \n        alt Potential trigger detected && not waitingForNextTrigger\n            %% Apply hysteresis if enabled\n            alt useHysteresis = true && not exact match\n                TriggerAlgo->>Validator: Verify trigger with hysteresis\n                Validator->>Validator: Calculate window size (IoT_Industrial_EdgeNode)\n                Validator->>Validator: _calculateTrend(IoT_Industrial_EdgeNode) on signal segment\n                Note over Validator: Computes linear regression slope\n                \n                alt Trigger edge = Positive\n                    Validator->>TriggerAlgo: Valid if trend > 0 (IoT_Industrial_EdgeNode)\n                else Trigger edge = Negative\n                    Validator->>TriggerAlgo: Valid if trend < 0 (IoT_Industrial_PLC_Logic)\n                end\n            else Simple validation\n                TriggerAlgo->>TriggerAlgo: Accept trigger candidate as valid\n            end\n            \n            %% Process valid trigger\n            alt Trigger is valid\n                TriggerAlgo->>TriggerAlgo: Create trigger marker\n                \n                alt Exact match at trigger level\n                    TriggerAlgo->>TriggerAlgo: Mark existing point as trigger\n                else Need interpolation\n                    TriggerAlgo->>Interpolator: Calculate precise trigger crossing\n                    Interpolator->>Interpolator: Calculate ratio using: (IoT_Industrial_MQTT_Broker) / (IoT_Industrial_MQTT_Broker)\n                    Interpolator->>Interpolator: Find x at crossing: x1 + ratio * (IoT_Industrial_EdgeNode)\n                    Interpolator->>TriggerAlgo: Return interpolated DataPoint with isTrigger=true\n                    TriggerAlgo->>TriggerAlgo: Replace point with interpolated trigger point\n                end\n                \n                alt First trigger found\n                    TriggerAlgo->>TriggerAlgo: Record firstTriggerX for alignment\n                    TriggerAlgo->>TriggerAlgo: Set foundFirstTrigger = true\n                end\n                \n                alt triggerMode = normal\n                    TriggerAlgo->>TriggerAlgo: Set waitingForNextTrigger = true\n                    Note over TriggerAlgo: Prevents multiple triggers until signal returns\n                else triggerMode = single\n                    TriggerAlgo->>TriggerAlgo: Keep waitingForNextTrigger = false\n                    Note over TriggerAlgo: Will capture only one triggered waveform\n                end\n            end\n        end\n        \n        %% Reset waiting state when signal moves away from trigger zone\n        alt waitingForNextTrigger = true && triggerMode = normal\n            alt triggerEdge = positive\n                TriggerAlgo->>TriggerAlgo: If currentY < (IoT_Industrial_MQTT_Broker), reset waiting\n                Note over TriggerAlgo: Ensures signal must fall below threshold before next trigger\n            else triggerEdge = negative\n                TriggerAlgo->>TriggerAlgo: If currentY > (IoT_Industrial_ActuatorController), reset waiting\n                Note over TriggerAlgo: Ensures signal must rise above threshold before next trigger\n            end\n        end\n    end\n    \n    %% Final alignment and output\n    alt foundFirstTrigger = true\n        TriggerAlgo->>Processor: Align all points to first trigger (IoT_Industrial_MQTT_Broker)\n        Note over Processor: Makes trigger point appear at x=0\n    end\n    \n    %% Return results\n    Processor->>DataService: Return processed points with trigger markers\n    \n    alt triggerMode = single && trigger found\n        Processor->>DataService: Send pause message\n        DataService->>DataService: Set pause = true\n        Note over DataService: Freezes acquisition after capturing single triggered waveform\n    end",
  "content_size": 5688,
  "collected_at": "2026-02-06T14:08:21.428771",
  "compilation_status": "failed",
  "license": "gitlab_repo",
  "license_name": "GitLab Repository",
  "license_url": "https://gitlab.com",
  "compilation_error": "[WinError 2] 系统找不到指定的文件。",
  "augmentation_domain": "IoT_Industrial",
  "seed_id": "gl_packet-beta_00367",
  "cscw_dialogue": [
    {
      "turn_id": 1,
      "role": "Domain_Expert",
      "action_type": "propose",
      "utterance": "这里必须包含 IoT_Industrial_EdgeNode 和 IoT_Industrial_EdgeNode 这一块。",
      "elements_involved": [],
      "is_repair": false
    },
    {
      "turn_id": 2,
      "role": "Diagram_Editor",
      "action_type": "clarify",
      "utterance": "我把它加进去了，标签显示为 'IoT_Industrial_EdgeNode 和 IoT_Industrial_EdgeNode'，你看看合适吗？",
      "elements_involved": [],
      "is_repair": false
    },
    {
      "turn_id": 3,
      "role": "Domain_Expert",
      "action_type": "confirm",
      "utterance": "嗯，这样看起来很清晰。",
      "elements_involved": [],
      "is_repair": false
    },
    {
      "turn_id": 4,
      "role": "Diagram_Editor",
      "action_type": "execute",
      "utterance": "[系统日志: Editor 更新了图表代码以反映上述结构]",
      "elements_involved": [
        "_readDataFromQueue",
        "size"
      ],
      "is_repair": false
    },
    {
      "turn_id": 5,
      "role": "Domain_Expert",
      "action_type": "propose",
      "utterance": "我们需要加一个处理 IoT_Industrial_EdgeNode 和 IoT_Industrial_EdgeNode 的环节。",
      "elements_involved": [],
      "is_repair": false
    },
    {
      "turn_id": 6,
      "role": "Diagram_Editor",
      "action_type": "clarify",
      "utterance": "明白，所以它是承接上一步的，内容是 'IoT_Industrial_EdgeNode 和 IoT_Industrial_EdgeNode'？",
      "elements_involved": [],
      "is_repair": false
    },
    {
      "turn_id": 7,
      "role": "Domain_Expert",
      "action_type": "confirm",
      "utterance": "可以，继续吧。",
      "elements_involved": [],
      "is_repair": false
    },
    {
      "turn_id": 8,
      "role": "Diagram_Editor",
      "action_type": "execute",
      "utterance": "[系统日志: Editor 更新了图表代码以反映上述结构]",
      "elements_involved": [
        "_calculateTrend",
        "0"
      ],
      "is_repair": false
    },
    {
      "turn_id": 9,
      "role": "Domain_Expert",
      "action_type": "propose",
      "utterance": "我们需要加一个处理 IoT_Industrial_PLC_Logic 和 IoT_Industrial_MQTT_Broker 的环节。",
      "elements_involved": [],
      "is_repair": false
    },
    {
      "turn_id": 10,
      "role": "Diagram_Editor",
      "action_type": "clarify",
      "utterance": "好的，我把它画成一个矩形框，名字叫 'IoT_Industrial_PLC_Logic 和 IoT_Industrial_MQTT_Broker'，对吧？",
      "elements_involved": [],
      "is_repair": false
    },
    {
      "turn_id": 11,
      "role": "Domain_Expert",
      "action_type": "confirm",
      "utterance": "嗯，这样看起来很清晰。",
      "elements_involved": [],
      "is_repair": false
    },
    {
      "turn_id": 12,
      "role": "Diagram_Editor",
      "action_type": "execute",
      "utterance": "[系统日志: Editor 更新了图表代码以反映上述结构]",
      "elements_involved": [
        "0",
        "trigger"
      ],
      "is_repair": false
    }
  ],
  "dialogue_metadata": {
    "total_turns": 12,
    "repair_count": 0,
    "grounding_acts_count": 6,
    "theoretical_framework": "Grounding in Communication (Clark & Brennan, 1991)"
  }
}