{
  "id": "gl_packet-beta_00357",
  "source": "gitlab",
  "source_url": "https://github.com/Ribosome2/game-dev-leads/blob/a2d34b6a00f2efff3866a9d66457c6b40140bada/%E7%BD%91%E7%BB%9C%E5%BB%B6%E8%BF%9F-%E6%8A%96%E5%8A%A8-%E5%92%8C%E5%8F%AF%E9%9D%A0%E6%80%A7.mmd",
  "source_note": "collected_from_github_additional",
  "github_repo": "Ribosome2/game-dev-leads",
  "diagram_type": "packet-beta",
  "code": "[Scia Reto](https://sciareto.org) mind map   \n> __version__=`1.1`,showJumps=`true`\n---\n\n# Root topic\n\n## 网络延迟的种类\n\n### Processing Delay\n\n#### 解析目标地址，路由到目标的接口就是处理延迟\n\n#### 很小的因素，大多数的路由处理器都很快的\n\n### Transmision Delay\n\n#### 把字节写入物理介质的时间就是传输延迟\n\n#### 通常是跟用户端的链路层连接优化\n\n### Queue Delay\n\n#### 如果协议到达的速度比路由器处理的时间还快，就会进入等待队列<br/>在队列的等待时间就是排队延迟\n\n#### 尽量用大的数据包，而不是小的数据包传输，因为<br/>一个1400\\-byte 的数据包要等待的延迟跟一个200\\-byte的延迟是差不多的\n\n### Propagation delay\n\n#### 传播延迟，不管声明介质，都没法超过光速传播\n\n## Jitter\n> leftSide=`true`\n\n\n### RTT的变化就称为网络抖动\n\n### 网络抖动会导致packet 乱序\n\n## PackaetLoss\n> leftSide=`true`\n\n\n### 数据包丢失原因\n\n#### Unreliable Physical medium\n\n#### Unreliable link layer \n\n##### 链路层有规则决定声明时候能发送数据\n\n##### Sometimes link layer channel is completely full<br/> and ann outgoing frame must be droped\n> leftSide=`true`\n\n\n#### Unreliable network layer \n> leftSide=`true`\n\n\n##### 收协议的速度快于处理速度，数据就会放到接受队列里面<br/>当队列满了的情况，就会开始丢弃队列里面的或者后来的数据\n\n###### 优先级由网络层的header里的QoS来决定\n\n## 从可靠性对比TCP和UDP\n\n### TCP的主要优势\n\n#### 经过实践验证，健壮可靠的实现\n\n#### 保证数据传递，并且按顺序传递\n\n#### 提供了复杂的阻塞控制机制\n\n### TCP的缺点\n\n#### 数据的发送和处理得按顺序有时就会造成问题\n\n##### 低优先级的数据影响到高优先级的数据接收\n\n###### 比如Moba或者实时同步要求高的游戏，<br/>播放声音的协议（低优先级）丢包，<br/>就会导致移动或者出技能数据要跟着延迟\n\n##### Two separate streams of reliably order data  interfering with each other\n\n###### 比如游戏中的聊天信息，是需要按顺序处理<br/>但是跟FPS游戏中的headshot数据包并不需要顺序关系\n\n##### Retrasmission of stale game state\n\n###### 假设玩家B在5秒内一直从x坐标0跑到100，每秒发5次B的坐标<br/>在A玩家看来，只有中间有任意的包丢失，服务器就会重发，<br/>即使坐标数据已经过时了\n\n#### 阻塞控制\n\n##### not uniformly configurable on all platforms\n\n##### Nagle 算法可以让数据包延迟最多半秒发送\n\n###### 用TCP传输的游戏大多数都会停掉Nagle算法来避免这种问题<br/>即使是放弃它所带来的减少packat数量的好处\n\n#### 为了记录哪些数据需要重发，就得由系统分配<br/>很多资源来管理连接 难以自定义控制内存\n\n##### 基本上所有的数据都得保留备份\n\n### UDP\n\n#### 缺点是没有自带的可靠特性\n\n#### 可以自己造自己想要的可靠性\n\n##### 丢包的时候，只发最新的数据，而不是重发可能过时的数据\n\n#### 自己实现的没有经过验证，可能没有tcp那样bug\\-free\n\n##### 可以用第三方的UDP库来降低这种风险\n\n###### 比如RakNet或者Photon\n\n####### RakNet\n- LINK\n<pre>http://www.jenkinssoftware.com/</pre>\n\n## Packet Delivery Notification\n> leftSide=`true`\n\n\n### 选择UDP就要实现这个模块\n\n#### DeliveryNotificationManager\n\n##### 要实现的三个功能\n\n###### 发送时 uniquely identify and tag each packet it sends out\n\n####### Tagging Outgoing Packets\n\n######## 参考了TCP的设计，给每个packet赋值了一个序列号<br/>但是这个序列号不像TCP一样表示stream里面的bytes数<br/>只是作为一个唯一id\n\n######## InFlightPacket 发了但是还没被确认收到的\n\n###### 接收时，对决定接收的packet发送确认接收\n> leftSide=`true`\n\n\n####### DeliveryNotificationManager::ProcessSequenceNumber\n\n######## 用NextExpectedSequenceNumber来决定<br/>packet要不要处理，或者丢弃 这就是保证处理顺序的机制\n\n######## 读到序列号的三种情况\n\n######### 序列号跟预期的序列号一致\n> fillColor=`#49FF00`\n\n\n########## 确认接收，并处理协议，预期序列号\\+1\n\n######### 序列号比预期的要小\n> leftSide=`true`,mmd.emoticon=`emotion_ghost`\n\n\n########## 意味着已经有更新的packet到达了，这个时候不需要处理，也不需要确认\n\n######### 序列号比预期的要大\n> fillColor=`#00DBFF`,leftSide=`true`,mmd.emoticon=`lightning`\n\n\n########## 序列号小的延迟或者丢包了就会发生这种情况\n> fillColor=`#00DBFF`\n\n\n########## 这种情况直接更新预期序列号，并且进行处理和确认，<br/>意味着就算后面序列号小的来也不处理了\n> fillColor=`#00DBFF`,leftSide=`true`\n\n\n########## 做的事情跟第一种是一样的\n> fillColor=`#00DBFF`\n\n\n######## 要确认的序列号不是每个都单独确认，<br/>而是收集起来一次性发区间确认\n\n######### 区间连续的话发一个AckRange就行，不连续就构建多个区间\n\n###### 发送端处理确认包，通知依赖模块<br/>哪些协议被接收了，哪些被丢弃了\n\n####### DeliveryNotificationManager::ProcessAcks\n\n######## 和mInFlightPackets 对比区间，已经确认的移除掉\n\n####### ProcessTimedOutPackets\n> leftSide=`true`\n\n\n######## 处理那些超时没有回复确认的协议\n\n####### 处理成功和失败都会统计数量\n\n######## 如果丢包率太高可能通知合适的模块降低发包频率\n\n##### 保证不会处理过时协议\n\n###### 比如新packet到了，旧的协议就当作被丢掉，忽视掉<br/>防止旧协议覆盖新数据\n\n## Improved Latency Handling\n\n### conservative algorithm\n\n#### 客户端不做任何处理，等服务网同步指令才做处理<br/>这种就是保守算法\n\n### ClientSide Interpolation\n\n#### 不直接用服务的发位置更新坐标，而是本地用local perception filter来进行插值\n\n#### 是在拿到服务器数据之后才做插值，只是看起来更平滑了，但是实际比保守算法更延后？\n\n### ClientSide Predition\n\n#### 从interpolation 转到extrapolation\n\n#### 这里没懂，comeback\n\n#### Dead Reckonging \n> fillColor=`#FF6400`\n\n\n##### 航海术语，航道预测，\n\n###### dead 可能是拼写错误流传，可能是deduced\n\n##### 游戏中就是假设游戏实体会保持做目前做的事情，，然后预测实体的行为的过程\n\n##### 相对保守算法，这算是optimistic algorithm\n\n##### 遇到预测不对的三种处理方式\n\n###### 立刻更新为最新的，能保证最新但是会跳\n> fillColor=`#FF6400`\n\n\n###### 插值\n\n###### Second\\-order state adjustment\n\n### ClientSide Rewind\n\n### Server Side Rewind\n\n#### 长距离，及时击中的武器同步\n\n#### 核心思想是把服务器的状态回滚到玩家射击时候观察到状态\n\n#### 需要对客户端预测的方法做些调整\n\n##### remote player 不进行dead reckoning\n\n##### Use local move  prediction and move replay \n\n###### 本地玩家还是即时响应？\n\n##### Record the client's view in each move packet sent to  the server\n\n##### On server ,store the poses of every relevant object for the last several frames\n",
  "content_size": 4365,
  "collected_at": "2026-02-06T14:08:12.418226",
  "compilation_status": "failed",
  "compilation_error": "[WinError 2] 系统找不到指定的文件。",
  "license": "none",
  "license_name": "No License",
  "license_url": "",
  "repo_stars": 1,
  "repo_forks": 0,
  "repo_owner": "Ribosome2",
  "repo_name": "game-dev-leads",
  "repo_description": "游戏开发知识整理",
  "repo_language": "Mermaid",
  "repo_topics": [],
  "repo_created_at": "2023-08-16T01:50:06Z",
  "repo_updated_at": "2025-07-21T03:17:15Z"
}