{
  "id": "gh_architecture_01772",
  "source": "github",
  "source_url": "https://github.com/animicaorg/all/blob/81c5557a26defd300015b53827699b5d5989bb17/docs/diagrams/DA_PIPELINE.mmd",
  "github_repo": "animicaorg/all",
  "github_file_path": "docs/diagrams/DA_PIPELINE.mmd",
  "diagram_type": "architecture",
  "code": "%% Mermaid: Data Availability Pipeline — blob → NMT → erasure → sampling\n%% View online: https://mermaid.live\n\nflowchart TB\n  %% ===================== INPUTS =====================\n  subgraph IN[Inputs]\n    direction TB\n    BlobIn[Blob (bytes)\\n+ mime/meta]:::data\n    NsSel[Namespace ID (ns)]:::data\n    Params[(DA Params)\\nErasure: k,n, shard_size\\nNMT: leaf codec, hash\\nSampling: p_fail target]:::data\n  end\n\n  %% ===================== INGEST =====================\n  subgraph INGEST[Ingest & Chunking]\n    direction TB\n    Chunker[Chunker\\nsplit → chunks of shard_size]:::calc\n  end\n\n  %% ===================== ERASURE =====================\n  subgraph EC[Erasure Coding]\n    direction TB\n    Partitioner[Partitioner\\npack chunks → k data shards]:::calc\n    RS[Reed–Solomon Encoder\\nproduce n shards (k data + n−k parity)]:::calc\n    Layout[Matrix Layout\\nrows/cols; padding rules]:::calc\n  end\n\n  %% ===================== NAMESPACING & NMT =====================\n  subgraph NMT[NMT Leaves & Root]\n    direction TB\n    LeafCodec[Leaf Codec\\nleaf = ns || len || data]:::calc\n    NmtBuild[Namespaced Merkle Tree\\nbuild/append; maintain ns ranges]:::calc\n    DaCommit[DA Commitment = NMT Root]:::cons\n  end\n\n  %% ===================== STORE & RECEIPT =====================\n  subgraph STORE[Commit, Store & Receipt]\n    direction TB\n    BlobIndex[Index shards & meta\\n(commitment ↔ ns, size)]:::core\n    Receipt[Post Receipt\\n{commitment, ns, size, sig?}]:::cons\n  end\n\n  %% ===================== HEADER INTEGRATION =====================\n  subgraph HEADER[Header Integration]\n    direction TB\n    BlockAdapter[Block Adapter\\ncollect blob commitments]:::core\n    DaRootBlock[Header.daRoot\\n(canonical aggregation of blob commitments)]:::cons\n  end\n\n  %% ===================== RETRIEVAL =====================\n  subgraph RETRIEVE[Retrieval API]\n    direction TB\n    GetBlob[GET /da/blob/{commitment}\\nstream shards → reassemble]:::core\n    GetProof[GET /da/proof/{commitment}?indices=…\\nreturns inclusion/range proofs]:::core\n  end\n\n  %% ===================== SAMPLING & LIGHT VERIFY =====================\n  subgraph SAMPLING[DAS Sampling & Light Verification]\n    direction TB\n    Plan[Query Plan Builder\\nuniform/stratified samples]:::calc\n    FetchSamples[Fetch sample shards + proofs\\n(from DA nodes)]:::core\n    VerifyProofs[Verify proofs against header.daRoot\\n(NMT inclusion & ns-range)]:::calc\n    Prob[Audit Probability\\np_fail ≤ target]:::calc\n    Verdict[Availability Verdict\\n\"available\" if success ratio ≥ threshold]:::cons\n  end\n\n  %% ===================== FLOWS =====================\n  BlobIn --> Chunker --> Partitioner --> RS --> Layout --> LeafCodec --> NmtBuild --> DaCommit\n  NsSel --> LeafCodec\n  Params --> Chunker\n  Params --> RS\n  Params --> LeafCodec\n  Params --> Plan\n  DaCommit --> BlobIndex --> Receipt\n  DaCommit --> BlockAdapter --> DaRootBlock\n  Receipt --> GetBlob\n  Receipt --> GetProof\n  DaRootBlock --> VerifyProofs\n  GetProof --> VerifyProofs --> Prob --> Verdict\n  Plan --> FetchSamples --> VerifyProofs\n\n  %% ===================== NOTES =====================\n  %% - Erasure: Any k of n shards suffice to reconstruct (assuming RS(k,n)).\n  %% - Namespacing: NMT ensures leaves are ordered by ns; range proofs attest to a namespace slice.\n  %% - Commitment: Per-blob NMT root is the commitment; block header.daRoot aggregates commitments deterministically.\n  %% - Sampling: Light clients verify a small random set of samples; with enough successes, the probability\n  %%   of undetected withholding drops below the configured p_fail target.\n  %% - Determinism: leaf codec, hashing, and ordering must be fixed and canonical across implementations.\n\n  %% ===================== STYLES =====================\n  classDef data fill:#f3f4f6,stroke:#888,stroke-width:1,color:#222;\n  classDef calc fill:#93c5fd,stroke:#225,stroke-width:1,color:#001;\n  classDef cons fill:#34d399,stroke:#0b4,stroke-width:1,color:#062;\n  classDef core fill:#10b981,stroke:#0b4,stroke-width:1,color:#062;\n",
  "content_size": 4004,
  "collected_at": "2026-02-06T02:03:09.327635",
  "compilation_status": "failed",
  "compilation_error": "[WinError 2] 系统找不到指定的文件。",
  "license": "ofl-1.1",
  "license_name": "SIL Open Font License 1.1",
  "license_url": "https://api.github.com/licenses/ofl-1.1",
  "repo_stars": 0,
  "repo_forks": 0
}