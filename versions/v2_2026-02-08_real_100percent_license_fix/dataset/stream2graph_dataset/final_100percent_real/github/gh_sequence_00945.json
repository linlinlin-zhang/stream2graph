{
  "id": "gh_sequence_00945",
  "source": "github",
  "source_url": "https://github.com/HectorLMF/Modelado-PRC6/blob/717b77e992e71f9d21376b40c7fc5a235a7842b0/docs/diagrams/De%20Secuencia/Clasificar%20instancia.mmd",
  "github_repo": "HectorLMF/Modelado-PRC6",
  "github_file_path": "docs/diagrams/De Secuencia/Clasificar instancia.mmd",
  "diagram_type": "sequence",
  "code": "sequenceDiagram\n    participant Usuario\n    participant Main\n    participant Scanner\n    participant Dataset\n    participant Instance as Instancia\n    participant KNNClassifier\n    participant DistanceMetric\n    participant CaseWeightingStrategy\n    participant ClassificationRule\n\n    Usuario->>Main: choose(4)\n    note right of Main: Usuario selecciona la opción de clasificación\n\n    Main->>Scanner: nextLine()\n    note right of Scanner: Lee la línea de entrada con valores de la instancia\n\n    Scanner-->>Main: \"v1,v2,...,vn\"\n    note right of Main: Devuelve la cadena introducida\n\n    Main->>Instancia: new Instance()\n    note right of Instancia: Crea el objeto donde almacenar valores\n\n    Main->>Dataset: getAttributes()\n    note right of Dataset: Obtiene lista de atributos del dataset\n\n    Dataset-->>Main: List<Attribute>\n    note right of Main: Main recibe los metadatos de los atributos\n\n    loop Construir instancia\n        alt atributo es clase\n            Main->>Instancia: addValue(\"\")\n            note right of Instancia: Añade placeholder para la clase\n        else atributo cuantitativo\n            Main->>Instancia: addValue(parseFloat(token))\n            note right of Instancia: Convierte token a número y lo añade\n        else\n            Main->>Instancia: addValue(token)\n            note right of Instancia: Añade token como cadena\n        end\n    end\n\n    Main->>KNNClassifier: classify(Instancia)\n    note right of KNNClassifier: Inicia el proceso k-NN\n\n    KNNClassifier->>Dataset: getInstances()\n    note right of Dataset: Obtiene todas las instancias de entrenamiento\n\n    Dataset-->>KNNClassifier: List<Instance>\n    note right of KNNClassifier: Recibe la lista para comparar\n\n    loop Para cada instancia de entrenamiento\n        KNNClassifier->>DistanceMetric: compute(trainInst,Instancia,attrs,weights)\n        note right of DistanceMetric: Calcula distancia ponderada\n        DistanceMetric-->>KNNClassifier: distancia d\n        note right of KNNClassifier: Recibe valor de distancia\n        KNNClassifier->>KNNClassifier: neighbors.add(new Neighbor(trainInst,d))\n        note right of KNNClassifier: Almacena vecino y distancia\n    end\n\n    KNNClassifier->>KNNClassifier: sort(neighbors)\n    note right of KNNClassifier: Ordena vecinos por distancia ascendente\n\n    KNNClassifier->>KNNClassifier: limit = min(k,neighbors.size)\n    note right of KNNClassifier: Determina cuántos vecinos usar\n\n    loop i = 0..limit-1\n        KNNClassifier->>CaseWeightingStrategy: getWeight(i+1,neighbors[i].distance)\n        note right of CaseWeightingStrategy: Calcula peso según posición/distancia\n        CaseWeightingStrategy-->>KNNClassifier: pesoVote\n        note right of KNNClassifier: Recibe peso para este vecino\n        KNNClassifier->>KNNClassifier: votes.put(label,+pesoVote)\n        note right of KNNClassifier: Acumula votos ponderados\n    end\n\n    KNNClassifier->>ClassificationRule: predictClass(votes)\n    note right of ClassificationRule: Aplica regla de votación\n\n    ClassificationRule-->>KNNClassifier: clasePredicha\n    note right of KNNClassifier: Recibe la clase ganadora\n\n    KNNClassifier-->>Main: clasePredicha\n    note right of Main: Devuelve resultado al main\n\n    Main-->>Usuario: println(\"Clase predicha: \"+clasePredicha)\n    note right of Usuario: Muestra la clase en consola\n",
  "content_size": 3328,
  "collected_at": "2026-02-06T01:51:05.358390",
  "compilation_status": "failed",
  "license": "none",
  "license_name": "No License",
  "license_url": "",
  "repo_stars": 0,
  "repo_forks": 0,
  "compilation_error": "[WinError 2] 系统找不到指定的文件。"
}